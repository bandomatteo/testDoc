{"list":[{"title":"<anonymous>~#s","link":"<a href=\"-_anonymous_-.html#s\">s</a>"},{"title":"Agent","link":"<a href=\"Agent.html\">Agent</a>","description":"The Agent class is responsible for managing the agent's actions and interactions within the game.\nIt maintains the agent's beliefs, desires, and intentions, and uses pathfinding algorithms to navigate the game map.\nThe agent can perform actions such as picking up parcels, depositing them at bases, and exploring the map.\nIt also handles agent collisions and camping behavior based on the game state.\nThe agent's actions are logged for debugging and analysis purposes."},{"title":"Agent#achieveDeposit","link":"<a href=\"Agent.html#achieveDeposit\">achieveDeposit</a>","description":"This method is called when the agent intends to deposit parcels.\nIt checks if the agent is already at the nearest base and emits a putdown event if so.\nIf the agent is not at the base, it calculates a new path towards the base and checks for collisions with other agents.\nIf the agent reaches the base's coordinates, it emits a putdown event to deposit the carried parcels."},{"title":"Agent#achieveExplore","link":"<a href=\"Agent.html#achieveExplore\">achieveExplore</a>","description":"This method is called when the agent intends to explore the map.\nIt checks if the agent is camping on a spawn tile and updates the camping state based on the elapsed time.\nIf the agent is not camping, it calculates a new path towards a random spawn tile and checks for collisions with other agents.\nIf the agent reaches the spawn tile, it will either continue exploring or camp based on the spawn's sparsity.\nIf the agent is camping, it will perform random movements until the camping conditions are no longer met."},{"title":"Agent#achievePickup","link":"<a href=\"Agent.html#achievePickup\">achievePickup</a>","description":"This method is called when the agent intends to pick up a parcel.\nIt checks if the agent is already at the parcel's location and emits a pickup event if so.\nIf the agent is not at the parcel's location, it calculates a new path towards the parcel and checks for collisions with other agents.\nIf the agent reaches the parcel's coordinates, it emits a pickup event to the server."},{"title":"Agent#act","link":"<a href=\"Agent.html#act\">act</a>","description":"This method is called in each game loop to execute the agent's intentions based on the current game state.\nIt ensures that the agent acts on its most pressing intentions while considering the environment and other agents."},{"title":"Agent#filterIntentions","link":"<a href=\"Agent.html#filterIntentions\">filterIntentions</a>","description":"This method is typically called after generating desires to prioritize the most desirable actions for the agent.\nIt ensures that the agent acts on the most valuable intentions first, based on their calculated scores."},{"title":"Agent#generateDesires","link":"<a href=\"Agent.html#generateDesires\">generateDesires</a>","description":"This method is called to determine the agent's desires, which are then used to form intentions.\nIt evaluates the agent's current state, including carried parcels and their rewards,\nand generates a list of desires with associated scores.\nIt also considers the agent's position on the map and the distance to available parcels.\nIf the agent is carrying parcels, it will also consider depositing them at the nearest base.\nFinally, it adds an intention to explore if no other intentions are more desirable."},{"title":"Agent#getBasePath","link":"<a href=\"Agent.html#getBasePath\">getBasePath</a>","description":"This method attempts to find a path to the nearest base tile.\nIf the agent is already at the target base, it returns immediately.\nIf the agent is not at the target base, it checks if the path to the base is clear.\nIf the path is not clear, it removes the current base from the map and waits for a specified time before restoring it.\nIt then finds a new target base and recalculates the path to it.\nThis process continues until a valid path is found or the maximum number of tries is reached."},{"title":"Agent#getNewPath","link":"<a href=\"Agent.html#getNewPath\">getNewPath</a>","description":"This method calculates a path from the agent's current position to the specified target using the A* algorithm.\nIt initializes the path index to 0 and temporarily removes visible agents from the map to avoid collisions.\nThe path is then calculated and stored in the agent's path property.\nAfter the path is calculated, the removed agents are restored to their original tile types.\nThis allows the agent to find a path without being blocked by other agents while still considering their presence in the game."},{"title":"Agent#getPath","link":"<a href=\"Agent.html#getPath\">getPath</a>","description":"This method calculates a path from the agent's current position to the specified target using the A* algorithm.\nIt initializes the path index to 0 and stores the calculated path in the agent's path property.\nThe path is used to determine the agent's movement towards the target tile."},{"title":"Agent#log","link":"<a href=\"Agent.html#log\">log</a>","description":"This method checks if the provided log level is included in the agent's log levels.\nIf it is, it calls the `log` function with the log levels, log level, and arguments.\nThis allows for flexible logging of messages based on the agent's current log configuration."},{"title":"Agent#oneStep","link":"<a href=\"Agent.html#oneStep\">oneStep</a>","description":"This method is called in each game loop to move the agent towards its next destination.\nIt calculates the direction to the next tile in the path and performs the movement action.\nIf the agent has reached the end of its path, it resets the last intention to indicate that no further action is needed."},{"title":"Agent#oneStepCheckAgents","link":"<a href=\"Agent.html#oneStepCheckAgents\">oneStepCheckAgents</a>","description":"This method is called in each game loop to handle agent movement and collision detection.\nIt ensures that the agent can navigate the map while avoiding collisions with other agents.\nIf a collision is detected, it will wait for a specified time before attempting to get a new path.\nIf no collisions are detected, it will proceed with the next step in the agent's path."},{"title":"Agent#updateBeliefs","link":"<a href=\"Agent.html#updateBeliefs\">updateBeliefs</a>","description":"This method is typically called in each game loop to keep the agent's beliefs up-to-date with the current game state."},{"title":"AgentStore","link":"<a href=\"AgentStore.html\">AgentStore</a>","description":"This class is responsible for managing the agents in the game.\nIt allows adding, removing, and updating agents, as well as finding visible agents based on the player's position and the game configuration.\nIt uses a Map to store agents, where the key is the agent's ID and the value is an instance of OpponentAgent."},{"title":"AgentStore#addAgent","link":"<a href=\"AgentStore.html#addAgent\">addAgent</a>","description":"This method adds an agent to the AgentStore. If the agent is already present, it updates its state.\nIf the agent is new, it creates a new OpponentAgent instance and adds it to the map."},{"title":"AgentStore#findDirection","link":"<a href=\"AgentStore.html#findDirection\">findDirection</a>","description":"This method determines the direction in which an agent has moved based on its previous and current positions."},{"title":"AgentStore#removeAgent","link":"<a href=\"AgentStore.html#removeAgent\">removeAgent</a>","description":"This method removes an agent from the AgentStore based on its ID."},{"title":"AgentStore#updateAgent","link":"<a href=\"AgentStore.html#updateAgent\">updateAgent</a>","description":"This method updates the state of an existing agent in the AgentStore.\nIt updates the agent's position, direction, and timestamp."},{"title":"AgentStore#visible","link":"<a href=\"AgentStore.html#visible\">visible</a>","description":"This method returns an array of all agents currently stored in the AgentStore."},{"title":"Communication","link":"<a href=\"Communication.html\">Communication</a>","description":"This class is responsible for managing the communication related to parcel dropping and picking up.\nIt allows setting the dropped parcel's position, value, quantity, and the agent responsible for picking it up.\nIt also manages the distance to the nearest base for the dropped parcel.\nIt provides methods to reset the drop state and set the dropped parcel's details."},{"title":"Communication#droppedCoord","link":"<a href=\"Communication.html#droppedCoord\">droppedCoord</a>"},{"title":"Communication#resetDrop","link":"<a href=\"Communication.html#resetDrop\">resetDrop</a>","description":"This method clears the dropped parcel's details and the agent responsible for picking it up.\nIt also resets the coordinates and distance to the nearest base for the dropped parcel."},{"title":"Communication#setDropped","link":"<a href=\"Communication.html#setDropped\">setDropped</a>","description":"This method updates the state with the details of a dropped parcel and calculates the distance to the nearest base."},{"title":"DeliverooClient","link":"<a href=\"DeliverooClient.html\">DeliverooClient</a>","description":"This class is used to send and receive events related to the game.\nIt allows the agent to move, pick up parcels, drop off parcels, and receive updates about the game state.\nIt is typically used at the start of the game to set up the client with the agent's ID and to listen for events from the server."},{"title":"DeliverooClient#emitMove","link":"<a href=\"DeliverooClient.html#emitMove\">emitMove</a>","description":"This method is used to move the agent in the specified direction.\nIt emits a move event to the server, which updates the agent's position on the map."},{"title":"DeliverooClient#emitPickup","link":"<a href=\"DeliverooClient.html#emitPickup\">emitPickup</a>","description":"This method is used to emit a pickup event for the agent.\nIt is typically called when the agent is on a tile with a parcel and wants to pick it up.\nThe server will then update the agent's state to reflect that it is carrying the parcel."},{"title":"DeliverooClient#emitPutdown","link":"<a href=\"DeliverooClient.html#emitPutdown\">emitPutdown</a>","description":"This method is used to put down parcels at the agent's current location.\nIt emits a putdown event to the server and removes all parcels carried by the agent from the parcel store.\nIt is typically called when the agent reaches a base tile and needs to drop off parcels."},{"title":"DeliverooClient#onAgentsSensing","link":"<a href=\"DeliverooClient.html#onAgentsSensing\">onAgentsSensing</a>","description":"This method is used to listen for updates on agents in the game.\nIt allows the agent to receive updates about the state of other agents, including their positions and actions."},{"title":"DeliverooClient#onConfig","link":"<a href=\"DeliverooClient.html#onConfig\">onConfig</a>","description":"This method is used to listen for configuration updates from the server.\nIt allows the agent to receive updates about the game configuration, such as the map size and other settings."},{"title":"DeliverooClient#onMap","link":"<a href=\"DeliverooClient.html#onMap\">onMap</a>","description":"This method is used to listen for map updates from the server.\nIt allows the agent to receive updates about the game map, including the positions of parcels and bases."},{"title":"DeliverooClient#onParcelsSensing","link":"<a href=\"DeliverooClient.html#onParcelsSensing\">onParcelsSensing</a>","description":"This method is used to listen for updates on parcels in the game.\nIt allows the agent to receive updates about the state of parcels, including their positions and whether they have been picked up or delivered."},{"title":"DeliverooClient#onTile","link":"<a href=\"DeliverooClient.html#onTile\">onTile</a>","description":"This method is used to emit a drop event for the agent.\nIt is typically called when the agent is on a tile with a base and wants to drop off parcels.\nThe server will then update the agent's state to reflect that it has dropped off the parcels."},{"title":"DeliverooClient#onYou","link":"<a href=\"DeliverooClient.html#onYou\">onYou</a>","description":"This method is used to set up the client with the agent's ID.\nIt is typically called at the start of the game to ensure the client is ready to send and receive events."},{"title":"MapStore","link":"<a href=\"MapStore.html\">MapStore</a>","description":"This class is responsible for managing the game map, including adding tiles, calculating distances,\nand handling spawn tiles. It provides methods to add tiles, set their types, calculate distances,\nfind nearest bases, and perform k-means clustering for spawn tile assignment.\nIt also includes methods to reset k-means assignments and calculate the sparseness of spawn tiles.\nIt uses a Map to store tiles and their types, a Set to store bases, and a Map to store spawn tiles.\nIt also maintains a distance matrix for efficient distance calculations between tiles."},{"title":"MapStore#addTile","link":"<a href=\"MapStore.html#addTile\">addTile</a>","description":"This method adds a tile to the map, updates the spawn tiles if the tile is a spawn tile,\nand adds the tile to the bases set if it is a base tile."},{"title":"MapStore#bases","link":"<a href=\"MapStore.html#bases\">bases</a>"},{"title":"MapStore#calculateDistances","link":"<a href=\"MapStore.html#calculateDistances\">calculateDistances</a>","description":"This method computes the distance matrix for all valid tiles in the map. It first collects all valid (non-hole) positions,\ninitializes the distance matrix, and then applies the Floyd-Warshall algorithm to compute the shortest distances between all pairs of tiles."},{"title":"MapStore#calculateSparseness","link":"<a href=\"MapStore.html#calculateSparseness\">calculateSparseness</a>","description":"This method calculates the ratio of spawn tiles to the total number of cells in the map that are not empty.\nIt also calculates the ratio of spawn tiles to the maximum number of parcels allowed in the server configuration.\nIf both ratios are below the defined thresholds in the config, it sets isSpawnSparse to true."},{"title":"MapStore#distance","link":"<a href=\"MapStore.html#distance\">distance</a>","description":"This method retrieves the indices of the given coordinates from the indexOf map and uses them to access the distance matrix.\nIf either coordinate is not found in the indexOf map, it returns Infinity."},{"title":"MapStore#kMeans","link":"<a href=\"MapStore.html#kMeans\">kMeans</a>","description":"This method initializes k prototypes with random values, associates each spawn tile to the nearest prototype using Euclidean distance,\nand updates the prototypes to the means of the associated tiles. It continues iterating until the prototypes are stable or the maximum number of iterations is reached."},{"title":"MapStore#map","link":"<a href=\"MapStore.html#map\">map</a>"},{"title":"MapStore#nearestBase","link":"<a href=\"MapStore.html#nearestBase\">nearestBase</a>","description":"This method iterates through all bases in the map, calculates the distance from the given coordinates to each base,\nand returns the coordinates of the nearest base along with the minimum distance found."},{"title":"MapStore#printAllDistances","link":"<a href=\"MapStore.html#printAllDistances\">printAllDistances</a>","description":"This method iterates through all pairs of coordinates in the map and logs the distance between them.\nIt is useful for debugging and understanding the distance relationships in the map."},{"title":"MapStore#randomSpawnTile","link":"<a href=\"MapStore.html#randomSpawnTile\">randomSpawnTile</a>","description":"This method filters the spawn tiles to find those that are available and either assigned to the given agent or unassigned.\nIt then selects a random tile from the filtered list and returns its coordinates."},{"title":"MapStore#resetKmeans","link":"<a href=\"MapStore.html#resetKmeans\">resetKmeans</a>","description":"This method iterates through all spawn tiles and sets their assignedTo property to null,\neffectively resetting the k-means clustering assignments."},{"title":"MapStore#setType","link":"<a href=\"MapStore.html#setType\">setType</a>","description":"This method updates the type of a tile in the map. If the old type was SPAWN, it marks the spawn tile as unavailable.\nIf the old type was BASE, it removes the base from the set. It then sets the new type and updates spawn tiles and bases accordingly."},{"title":"MapStore#size","link":"<a href=\"MapStore.html#size\">size</a>","description":"This method sets the size of the map, which is used for distance calculations."},{"title":"MapStore#spawnTiles","link":"<a href=\"MapStore.html#spawnTiles\">spawnTiles</a>"},{"title":"Me","link":"<a href=\"Me.html\">Me</a>","description":"This class holds the state of the local player, including their ID, team information, position, score, and penalty.\nIt provides a method to update the player's state based on server payload and time."},{"title":"Me#update","link":"<a href=\"Me.html#update\">update</a>","description":"This method updates the player's ID, name, team information, position, score, and penalty,\nas well as the timestamp and frame number for the current state."},{"title":"MultiAgent","link":"<a href=\"MultiAgent.html\">MultiAgent</a>","description":"The MultiAgent class implements a BDI architecture to manage agent behavior in the Deliveroo game.\nIt allows agents to generate desires based on the current state of the game, filter those desires into intentions, and execute actions accordingly.\nThe class supports both master and slave agents, enabling them to coordinate actions and share information.\nIt includes methods for pathfinding, collision detection, and managing the agent's state, such as movement, camping, and exploring the map.\nThe agent can perform actions such as picking up parcels, depositing them, exploring the map, and avoiding collisions with other agents.\nThe class is designed to be extensible, allowing for the addition of new intentions and actions as needed.\nIt also includes logging functionality to track agent actions and intentions"},{"title":"MultiAgent#MultiAgent","link":"<a href=\"MultiAgent_MultiAgent.html\">MultiAgent</a>","description":"The constructor initializes the MultiAgent instance with the provided parameters.\nIt sets up the agent's state, including desires, intentions, pathfinding variables, and timers for exploring and camping.\nIt also initializes logging levels for tracking agent actions and intentions.\nThe agent's communication model is set up to allow for interaction with other agents and the game server.\nThe constructor prepares the agent to perform actions based on its beliefs, desires, and intentions."},{"title":"MultiAgent#achieveDeposit","link":"<a href=\"MultiAgent.html#achieveDeposit\">achieveDeposit</a>","description":"This method is responsible for achieving the deposit action by moving to the nearest base and depositing the carried parcels.\nIt checks if the current intention is equal to the last intention and updates the path to the nearest base accordingly.\nIf the agent is already at the base's location, it emits a putdown event to the server.\nThe method uses the `oneStepCheckAgents` method to check for collisions with other agents before performing the deposit action.\nThe agent's state is updated to reflect the deposit action, and it logs the action based on whether it is a master or slave agent."},{"title":"MultiAgent#achieveDropAndGoAway","link":"<a href=\"MultiAgent.html#achieveDropAndGoAway\">achieveDropAndGoAway</a>","description":"This method is responsible for achieving the drop and go away action by dropping the carried parcels and moving away from the current location.\nIt checks if there are possible moves available and, if so, sets the dropped state, puts down the parcels, and moves away.\nIf there are no possible moves, it communicates with the mate agent to move away.\nThe method updates the agent's state to reflect the drop and go away action, and it logs the action based on whether it is a master or slave agent."},{"title":"MultiAgent#achieveExplore","link":"<a href=\"MultiAgent.html#achieveExplore\">achieveExplore</a>","description":"This method is responsible for achieving the explore action by moving to a random spawn tile or camping on the spawn.\nIt checks if the current intention is equal to the last intention and updates the path to a random spawn tile accordingly.\nIf the agent is camping, it saves the camping start time and checks if the camping time has expired.\nIf the agent is not camping, it moves to a random spawn tile and checks for collisions with other agents.\nThe method updates the agent's state to reflect the explore action, and it logs the action based on whether it is a master or slave agent."},{"title":"MultiAgent#achieveGoAway","link":"<a href=\"MultiAgent.html#achieveGoAway\">achieveGoAway</a>","description":"This method is responsible for achieving the go away action by moving away from the current location.\nIt checks if there are possible moves available and, if so, moves away from the current location.\nIf there are no possible moves, it communicates with the mate agent to move away.\nThe method updates the agent's state to reflect the go away action, and it logs the action based on whether it is a master or slave agent."},{"title":"MultiAgent#achievePickup","link":"<a href=\"MultiAgent.html#achievePickup\">achievePickup</a>","description":"This method is responsible for achieving the pickup action by moving towards the specified parcel and picking it up.\nIt checks if the current intention is equal to the last intention and updates the path accordingly.\nIf the agent is already at the parcel's location, it emits a pickup event to the server.\nIf the pickup is from a dropped parcel, it resets the drop communication.\nThe method uses the `oneStepCheckAgents` method to check for collisions with other agents before performing the pickup action.\nThe agent's state is updated to reflect the pickup action, and it logs the action based on whether it is a master or slave agent."},{"title":"MultiAgent#act","link":"<a href=\"MultiAgent.html#act\">act</a>","description":"This method is responsible for executing the agent's actions based on its current intentions.\nIt iterates through the intentions and performs actions such as picking up parcels, depositing them, exploring the map, or moving away from other agents.\nIt checks for conditions such as whether the current intention is equal to the last intention and handles agent collisions.\nThe method uses helper methods to achieve specific actions, such as `achievePickup`, `achieveDeposit`, `achieveDropAndGoAway`, `achieveGoAway`, and `achieveExplore`.\nThe agent's actions are performed in a sequential manner, ensuring that it follows its intentions and updates its state accordingly."},{"title":"MultiAgent#filterIntentions","link":"<a href=\"MultiAgent.html#filterIntentions\">filterIntentions</a>","description":"This method filters the agent's desires into intentions by sorting them based on their scores.\nIt ensures that the most desirable actions are prioritized for execution.\nThe intentions are sorted in descending order, with higher scores indicating more desirable actions.\nThe filtered intentions are stored in the `this.intentions` array, which is later used to determine the agent's actions."},{"title":"MultiAgent#generateDesires","link":"<a href=\"MultiAgent.html#generateDesires\">generateDesires</a>","description":"This method is responsible for generating the agent's desires based on the current game state.\nIt evaluates the agent's carried parcels, calculates potential rewards for picking up new parcels, and considers the distance to the nearest base.\nIt also checks for the presence of other agents and their actions, allowing the agent to make informed decisions about its next actions.\nThe desires are sorted by score, with higher scores indicating more desirable actions.\nThe method also handles special cases, such as dropping parcels when close to a mate agent or moving away if another agent is stuck.\nThe generated desires are stored in the `this.desires` array, which is later filtered to create intentions for the agent to act upon."},{"title":"MultiAgent#getBasePath","link":"<a href=\"MultiAgent.html#getBasePath\">getBasePath</a>","description":"This method is responsible for getting the base path to the nearest base tile.\nIt checks if the agent is already at the base tile and returns if so.\nIf the agent is not at the base tile, it gets a new path to the nearest base using the getNewPath method.\nIf the base tile is not found, it removes the base from the map and sets a timer to restore it later.\nThe method ensures that the agent has a valid path to follow towards the nearest base tile, even if the base is temporarily removed from the map."},{"title":"MultiAgent#getNewPath","link":"<a href=\"MultiAgent.html#getNewPath\">getNewPath</a>","description":"This method is responsible for getting a new A* path to the specified target tile.\nIt removes visible agents from the map to ensure that the pathfinding algorithm does not consider them as obstacles.\nThe calculated path is stored in the `this.path` variable, which is later used for movement actions.\nThe method ensures that the agent has a valid path to follow towards the target tile, even in the presence of other agents."},{"title":"MultiAgent#getPath","link":"<a href=\"MultiAgent.html#getPath\">getPath</a>","description":"This method is responsible for getting the A* path to the specified target tile.\nIt initializes the path index to 0 and calculates the path using the astarSearch function.\nThe calculated path is stored in the `this.path` variable, which is later used for movement actions.\nThe method ensures that the agent has a valid path to follow towards the target tile."},{"title":"MultiAgent#log","link":"<a href=\"MultiAgent.html#log\">log</a>","description":"This method logs messages to the console based on the specified log level.\nIt uses the `log` utility function to filter and format the messages according to the log levels defined in the class.\nThe log levels can include master, slave, and action logs, allowing for flexible logging of agent actions and intentions."},{"title":"MultiAgent#oneStep","link":"<a href=\"MultiAgent.html#oneStep\">oneStep</a>","description":"This method performs one step of the agent path by moving the agent towards the next tile in the path.\nIt checks if the agent is already at the destination tile and does nothing if it is.\nIf the agent is not at the destination tile, it calculates the direction to move and performs the move action.\nThe method updates the agent's state to reflect the movement and increments the path index.\nIt also sets the moving state to false after the move is completed.\nThe method logs the action based on whether it is a master or slave agent."},{"title":"MultiAgent#oneStepCheckAgents","link":"<a href=\"MultiAgent.html#oneStepCheckAgents\">oneStepCheckAgents</a>","description":"This method performs a one-step check for agents in the next tile of the path.\nIt checks if any agent is in the tile the agent wants to go to and handles collisions accordingly.\nIf a collision is detected, it sets the colliding state and starts a timer.\nIf the timer expires, it gets a new path or base path based on the last intention.\nIf everything is clear, it performs one step of the agent path.\nThe method updates the agent's state to reflect the one-step check, and it logs the action based on whether it is a master or slave agent."},{"title":"MultiAgent#updateBeliefs","link":"<a href=\"MultiAgent.html#updateBeliefs\">updateBeliefs</a>","description":"This method is called to update the agent's beliefs about the game state.\nIt calculates the time difference since the last update and uses it to update the parcels data.\nThe parcels data is updated based on the current frame and the server configuration.\nThis method is essential for keeping the agent's beliefs up-to-date, allowing it to make informed decisions based on the latest game state."},{"title":"OpponentAgent","link":"<a href=\"OpponentAgent.html\">OpponentAgent</a>","description":"This class is used to represent an opponent agent in the game.\nIt contains properties such as id, name, teamId, teamName, x, y, score, timestamp, and direction.\nIt is typically used to store information about the agents that are not controlled by the player."},{"title":"Parcel","link":"<a href=\"Parcel.html\">Parcel</a>","description":"This class is used to represent a parcel in the game.\nIt contains properties such as id, carriedBy, x, y, reward, baseDistance, lastSeen, existingProb, nearestBase,\npotentialPickUpReward, and potentialPickUpRewardSlave."},{"title":"Parcel#calculateNearestBase","link":"<a href=\"Parcel.html#calculateNearestBase\">calculateNearestBase</a>","description":"This method calculates the nearest base to the parcel and updates the baseDistance and nearestBase properties.\nIt uses the nearestBase method from the MapStore to find the closest base and its distance.\nIf no base is found, the baseDistance remains Infinity and nearestBase is null."},{"title":"Parcel#calculatePotentialPickUpReward","link":"<a href=\"Parcel.html#calculatePotentialPickUpReward\">calculatePotentialPickUpReward</a>","description":"This method calculates the potential pickup reward for a parcel based on its position, carried value, and other parameters.\nIt updates the potentialPickUpReward or potentialPickUpRewardSlave property based on whether it is called from the master or slave instance."},{"title":"Parcel#calculateSurvivalProbability","link":"<a href=\"Parcel.html#calculateSurvivalProbability\">calculateSurvivalProbability</a>","description":"This method calculates the survival probability of the parcel based on the time since it was last seen and the number of agents.\nThe probability decreases exponentially with time and increases with the number of agents."},{"title":"Parcel#nearestBase","link":"<a href=\"Parcel.html#nearestBase\">nearestBase</a>"},{"title":"ParcelsStore","link":"<a href=\"ParcelsStore.html\">ParcelsStore</a>","description":"This class is responsible for managing parcels in the game.\nIt allows adding, removing, and updating parcels, as well as retrieving available parcels and those carried by players."},{"title":"ParcelsStore#addParcel","link":"<a href=\"ParcelsStore.html#addParcel\">addParcel</a>","description":"This method creates a new Parcel instance and adds it to the parcels map.\nIf the parcel already exists, it will update its state."},{"title":"ParcelsStore#available","link":"<a href=\"ParcelsStore.html#available\">available</a>","description":"This method filters the parcels map to return only those parcels that are not currently carried by any player\nand have an existing probability greater than or equal to 0.5.\nIt returns an array of available Parcel instances."},{"title":"ParcelsStore#availableIdSet","link":"<a href=\"ParcelsStore.html#availableIdSet\">availableIdSet</a>","description":"This method creates a Set from the IDs of all parcels that are currently available (not carried by any player).\nIt is useful for quickly checking the availability of parcels by their IDs."},{"title":"ParcelsStore#carried","link":"<a href=\"ParcelsStore.html#carried\">carried</a>","description":"This method filters the parcels map to return only those parcels that are currently being carried by the specified player.\nIt returns an array of Parcel instances that match the player's ID."},{"title":"ParcelsStore#map","link":"<a href=\"ParcelsStore.html#map\">map</a>"},{"title":"ParcelsStore#removeParcel","link":"<a href=\"ParcelsStore.html#removeParcel\">removeParcel</a>","description":"This method removes a parcel from the parcels map based on its ID."},{"title":"ParcelsStore#updateAll","link":"<a href=\"ParcelsStore.html#updateAll\">updateAll</a>","description":"This method updates the parcels store by first removing parcels that are no longer visible to the player,\nand then adding the new parcels from the provided array.\nIt checks the visibility of parcels based on the player's position and the game configuration."},{"title":"ParcelsStore#updateData","link":"<a href=\"ParcelsStore.html#updateData\">updateData</a>","description":"This method iterates through all parcels in the store, subtracts the specified amount from each parcel's reward,\nand updates its survival probability based on the current frame and agent count.\nIf a parcel's reward drops to zero or below, it is removed from the store."},{"title":"ParcelsStore#visible","link":"<a href=\"ParcelsStore.html#visible\">visible</a>","description":"This method filters the parcels map to return a Set of IDs of parcels that are within a certain distance from the player's position,\nas defined by the game configuration. It is useful for determining which parcels the player can interact with."},{"title":"ServerConfig","link":"<a href=\"ServerConfig.html\">ServerConfig</a>","description":"This class is used to manage the server configuration settings for the game.\nIt includes properties such as parcels_max, parcel_reward_avg, parcels_decaying_interval, clock,\nagents_obs_distance, and parcels_obs_distance."},{"title":"ServerConfig#updateConfig","link":"<a href=\"ServerConfig.html#updateConfig\">updateConfig</a>","description":"This method updates the server configuration properties based on the provided config object.\nIt sets the maximum number of parcels, average parcel reward, decaying interval for parcels,\nclock time, and observation distances for agents and parcels."},{"title":"astarSearch","link":"<a href=\"global.html#astarSearch\">astarSearch</a>","description":"This function implements the A* search algorithm to find the shortest path from start to goal.\nIt uses a heuristic based on the Manhattan distance to prioritize nodes in the search.\nThe function returns an array of coordinates representing the path from start to goal.\nIf no path is found, it returns an empty array."},{"title":"buildExecutor","link":"<a href=\"global.html#buildExecutor\">buildExecutor</a>","description":"Builds a PddlExecutor instance with action handlers for MOVE, PICKUP, and DEPOSIT."},{"title":"checkIfIamAtBase","link":"<a href=\"global.html#checkIfIamAtBase\">checkIfIamAtBase</a>","description":"This function checks if the current player's coordinates match any of the base locations in the map store.\nIt uses the coord2Key function to convert the player's coordinates into a key that can be checked against the map store's bases."},{"title":"direction","link":"<a href=\"global.html#direction\">direction</a>","description":"Determine the direction from one coordinate to another."},{"title":"executePlan","link":"<a href=\"global.html#executePlan\">executePlan</a>","description":"Executes a PDDL plan using the provided action handlers."},{"title":"exitCurrentBase","link":"<a href=\"global.html#exitCurrentBase\">exitCurrentBase</a>","description":"This function is used to exit the current base by first marking the tile as WALKABLE,\nthen finding the nearest base and moving towards it. After the move, it resets the tile type\nback to BASE. This is useful for scenarios where the player needs to leave the current base\nand find a new one, ensuring that the map state is correctly updated."},{"title":"generateDeliverooDomain","link":"<a href=\"global.html#generateDeliverooDomain\">generateDeliverooDomain</a>","description":"Returns a static PDDL domain definition (deliveroo-domain.pddl)."},{"title":"generateDeliverooProblem","link":"<a href=\"global.html#generateDeliverooProblem\">generateDeliverooProblem</a>","description":"Predicates that I have in the domain-file:\n- (at ?a - agent ?t - tile)\n -(parcel-at ?p - parcel ?t - tile)\n- (carrying ?a - agent ?p - parcel)\n- (base-at ?b - base ?t - tile)\n- (delivered ?p - parcel)\n-(adjacent ?t1 - tile ?t2 - tile)\n\nSo I need to use these predicates to build the problem\n\nThe PDDL problem definition has the following structure:\ndefine (problem PROBLEM_NAME)\n  (:domain DOMAIN_NAME)\n  (:objects OBJ1 OBJ2 ... OBJ_N)\n  (:init ATOM1 ATOM2 ... ATOM_N)\n  (:goal CONDITION_FORMULA)\n  )"},{"title":"getNearTiles","link":"<a href=\"global.html#getNearTiles\">getNearTiles</a>","description":"Gets the possible near tiles for movement based on the current position of the agent and its mate."},{"title":"getPlan","link":"<a href=\"global.html#getPlan\">getPlan</a>","description":"Generates a PDDL plan for the Deliveroo problem using the online solver."},{"title":"goAway","link":"<a href=\"global.html#goAway\">goAway</a>","description":"This function iterates a specified number of times, each time selecting a random direction\nfrom the possible near tiles around the agent's current position. It moves the agent in that\nrandom direction and updates the agent's position for the next iteration. This is useful for\nsimulating random movement away from the current position, which can be useful in various game scenarios."},{"title":"initApp","link":"<a href=\"global.html#initApp\">initApp</a>","description":"This function initializes the main components of the application:\n- DeliverooClient: The client to interact with the Deliveroo API.\n- Me: Represents the current player.\n- ParcelsStore: Manages the parcels in the game.\n- MapStore: Manages the game map\n- AgentStore: Manages the agents in the game.\n- ServerConfig: Holds the server configuration."},{"title":"main","link":"<a href=\"global.html#main\">main</a>","description":"Main function to initialize the Deliveroo client, models, and agent.\nIt sets up event listeners for client events and runs the agent's decision-making loop.\nThe agent updates its beliefs, generates desires, filters intentions, and acts based on the current state of the game.\nThe loop continues until the game is terminated, allowing the agent to continuously adapt to the game environment."},{"title":"main","link":"<a href=\"global.html#main\">main</a>","description":"Main function to initialize the Deliveroo client, models, and agents.\nIt sets up event listeners for client events and runs the agents' decision-making loop.\nThe agents update their beliefs, generate desires, filter intentions, and act based on the current state of the game.\nThe loop continues until the game is terminated, allowing the agents to continuously adapt to the game environment."},{"title":"main","link":"<a href=\"global.html#main\">main</a>","description":"This function initializes the application by creating instances of necessary classes, registers event handlers,\nwaits for the application to be ready, and then starts the main planning loop.\nIt serves as the entry point for the application, ensuring that all components are set up correctly before starting the main logic.\n* @throws {Error} - Throws an error if the application initialization or planning loop fails."},{"title":"main~firstLoad","link":"<a href=\"global.html#main#~firstLoad\">firstLoad</a>","description":"Function that executes only on the first loop of the game, after the agents are ready"},{"title":"makeOnDeposit","link":"<a href=\"global.html#makeOnDeposit\">makeOnDeposit</a>","description":"This function returns a handler that can be used to emit a putdown action.\nIt uses the client to emit a putdown event with the current parcels and the player's ID.\nThis will trigger the server to handle the deposit logic for the parcels."},{"title":"makeOnMove","link":"<a href=\"global.html#makeOnMove\">makeOnMove</a>","description":"This function returns a handler that can be used to move the agent to a specified target position.\nIt calculates the direction from the current position to the target position and uses the client to emit a move action.\nIt also waits for the move to complete and checks if the agent has reached the target position.\nIf the move fails or the agent does not reach the target position, it logs an error and rejects the promise."},{"title":"makeOnPickup","link":"<a href=\"global.html#makeOnPickup\">makeOnPickup</a>","description":"This function returns a handler that can be used to emit a pickup action.\nIt uses the client to emit a pickup event, which will trigger the server to handle the pickup logic."},{"title":"module:DIRECTIONS","link":"<a href=\"module-DIRECTIONS.html\">DIRECTIONS</a>","description":"This module provides utility functions for handling directions in a grid-based game.\nIt defines a set of constants for directions and includes a function to get the opposite direction.\nThe directions are represented as strings, and the module includes a function to determine the opposite direction\nbased on the input direction."},{"title":"module:DIRECTIONS.oppositeDirection","link":"<a href=\"module-DIRECTIONS.html#.oppositeDirection\">oppositeDirection</a>","description":"This function checks the input direction and returns its opposite. If the input is not a valid direction,\nit returns null."},{"title":"module:INTENTIONS","link":"<a href=\"module-INTENTIONS.html\">INTENTIONS</a>","description":"This module defines a set of constants representing different intentions or actions\nthat a player can take in a game. These intentions are used to guide the player's behavior\nand decision-making process during gameplay. Each intention is represented as a string constant.\nThe intentions include actions like picking up items, depositing items, exploring the game world,\ndropping items and moving away, and simply moving away without any specific action."},{"title":"module:LOG_LEVELS","link":"<a href=\"module-LOG_LEVELS.html\">LOG_LEVELS</a>","description":"This module provides a logging utility for different log levels in a game or application.\nIt defines constants for various log levels such as Master, Slave, and Action.\nThe `log` function allows logging messages at specified levels, filtering out messages that do not match the provided log level."},{"title":"module:LOG_LEVELS.log","link":"<a href=\"module-LOG_LEVELS.html#.log\">log</a>","description":"This function checks if the provided log level exists in the levelArray.\nIf it does, it logs the messages to the console with the specified log level prefix.\nThe log messages are formatted with the log level in square brackets followed by the message.\nThis is useful for filtering log messages based on their importance or category."},{"title":"module:TILE_TYPES","link":"<a href=\"module-TILE_TYPES.html\">TILE_TYPES</a>","description":"This module defines constants representing different types of tiles in a grid-based game.\nThe tile types include EMPTY, SPAWN, BASE, and WALKABLE.\nEach tile type is represented by a unique integer value.\nThese constants are used to identify the nature of each tile in the game world,\nallowing for efficient game logic and rendering."},{"title":"module:TILE_TYPES.isWalkableTile","link":"<a href=\"module-TILE_TYPES.html#.isWalkableTile\">isWalkableTile</a>","description":"This function checks if the given tile type is within the range of walkable tiles.\nIt returns true for SPAWN, BASE, and WALKABLE tiles, and false for EMPTY tiles."},{"title":"module:gameConfig","link":"<a href=\"module-gameConfig.html\">gameConfig</a>","description":"This module exports various constants used in the game configuration.\nThese constants include maximum ratios for green cells and spawn points, parameters for K-means clustering,\nsurvival lambda for parcels, agent camp time, and various base and agent configurations.\nThese constants are used throughout the game to ensure consistent behavior and performance."},{"title":"module:geometry","link":"<a href=\"module-geometry.html\">geometry</a>","description":"This module provides utility functions for geometric calculations in a grid-based game.\nIt includes functions to calculate the Manhattan distance and Euclidean distance between two points,\nas well as a function to determine if a player is moving towards a specific parcel based on their direction.\nThe functions operate on coordinate objects with x and y properties, and the direction is represented as a string.\nThe module is useful for pathfinding, collision detection, and movement logic in grid-based games."},{"title":"module:geometry.distance","link":"<a href=\"module-geometry.html#.distance\">distance</a>","description":"Calculates the Manhattan distance between two points.\nThe Manhattan distance is the sum of the absolute differences of their Cartesian coordinates.\nIt is often used in grid-based pathfinding algorithms."},{"title":"module:geometry.euclidean_distance","link":"<a href=\"module-geometry.html#.euclidean_distance\">euclidean_distance</a>","description":"Calculates the Euclidean distance between two points.\nThe Euclidean distance is the straight-line distance between two points in Euclidean space.\nIt is calculated using the Pythagorean theorem."},{"title":"module:geometry.goingTowardsParcel","link":"<a href=\"module-geometry.html#.goingTowardsParcel\">goingTowardsParcel</a>","description":"Checks if a player is moving towards a specific parcel based on their direction.\nThe function evaluates the player's direction and compares it with the position of the parcel.\nIf the player is moving in the direction of the parcel, it returns true; otherwise, it returns false."},{"title":"module:hashMap","link":"<a href=\"module-hashMap.html\">hashMap</a>","description":"Utility functions for converting between coordinate objects and string keys.\nThis module provides functions to convert a coordinate object with x and y properties into a string key,\nand to convert a string key back into a coordinate object.\nThe coordinate format is \"x,y\", where x and y are numbers.\nThe functions are useful for storing and retrieving coordinates in a hash map or similar data structure."},{"title":"module:hashMap.coord2Key","link":"<a href=\"module-hashMap.html#.coord2Key\">coord2Key</a>","description":"Converts a coordinate object to a string key."},{"title":"module:hashMap.key2Coord","link":"<a href=\"module-hashMap.html#.key2Coord\">key2Coord</a>","description":"Converts a string key back to a coordinate object."},{"title":"module:misc","link":"<a href=\"module-misc.html\">misc</a>","description":"This module provides utility functions for calculating scores related to parcel pickup in a grid-based game.\nIt includes a function to compute the score for picking up parcels based on various parameters such as starting position,\ngoal position, carried value, carried count, reward, pickup count, base distance, clock penalty, and map store.\nThe score is calculated by considering the total reward, distance to the parcel, and the number of parcels involved.\nThe function is useful for determining the optimal strategy for parcel pickup in the game."},{"title":"module:misc.getPickupScore","link":"<a href=\"module-misc.html#.getPickupScore\">getPickupScore</a>","description":"This function computes the score for picking up parcels by considering the total reward from carried parcels and the parcel being picked up,\nthe distance to the parcel, and the number of parcels involved. The score is adjusted by a clock penalty based on the total distance traveled.\nIf the base distance is not provided, it defaults to 0. The function uses the MapStore instance to calculate the distance between the start and goal positions.\nThe score is calculated as follows:\n1. Calculate the distance to the parcel using the MapStore's distance method.\n2. Compute the total reward as the sum of carried value and the reward for the parcel being picked up.\n3. Calculate the total distance as the sum of the distance to the parcel and the base distance.\n4. Determine the total number of parcels as the sum of carried count and pickup count.\n5. Finally, calculate the score as the total reward minus the product of total distance, total parcels, and clock penalty divided by the decaying interval."},{"title":"moveAndWait","link":"<a href=\"global.html#moveAndWait\">moveAndWait</a>","description":"This function emits a move command to the Deliveroo client and waits for the\nplayer's state to update with the new position. It listens for the 'onYou' event\nto confirm that the move has been processed and the player's position has been updated."},{"title":"moveToNearestBase","link":"<a href=\"global.html#moveToNearestBase\">moveToNearestBase</a>","description":"This function finds the nearest base on the map and uses the A* search algorithm to calculate\nthe path to that base. It then moves the agent in the direction of the first step in the path.\nIf a valid path is found, it moves the agent and returns true. If no base is found or no valid\npath exists, it logs an error message and returns false."},{"title":"planWithDynamicAgents","link":"<a href=\"global.html#planWithDynamicAgents\">planWithDynamicAgents</a>","description":"This function generates a plan for the current player based on the current map state, visible agents, and parcels.\nIt temporarily removes agents from the map to avoid interference during planning.\nAfter generating the plan, it restores the agents back to their original state on the map.\nIf an error occurs during planning, it logs the error and returns an empty plan."},{"title":"randomMoveAndBack","link":"<a href=\"global.html#randomMoveAndBack\">randomMoveAndBack</a>","description":"This function checks the surrounding tiles for walkable paths and randomly selects one to move in.\nAfter moving in the random direction, it immediately moves back to the original position.\nThis is useful for testing movement logic or simulating random behavior in the game."},{"title":"registerEventHandlers","link":"<a href=\"global.html#registerEventHandlers\">registerEventHandlers</a>","description":"This function sets up event listeners for various events emitted by the Deliveroo client.\nIt updates the player state, map tiles, configuration, parcels sensing, and agents sensing.\nIt ensures that the application reacts to changes in the game state and updates the relevant models accordingly."},{"title":"runPlanningLoop","link":"<a href=\"global.html#runPlanningLoop\">runPlanningLoop</a>","description":"This function runs the main planning loop for the application.\nIt continuously checks the game state, computes a plan using dynamic agents, and executes the plan.\nIf no plan is found, it attempts to move towards the nearest base.\nIt handles errors during planning and execution, ensuring that the application remains responsive and can recover from failures."},{"title":"sanitizePddlName","link":"<a href=\"global.html#sanitizePddlName\">sanitizePddlName</a>","description":"This function is useful for ensuring that names used in PDDL (Planning Domain Definition Language)\nare valid and follow the naming conventions required by PDDL, such as using lowercase letters,\nnumbers, and underscores, while avoiding spaces and special characters."},{"title":"smartMove","link":"<a href=\"global.html#smartMove\">smartMove</a>","description":"This function calculates the path from the current position to the target position\nusing the A* search algorithm. It then iterates through each step in the path,\ndetermines the direction to move in, and calls the `moveAndWait` function to \nmove the agent step by step."},{"title":"smartMoveToNearestBase","link":"<a href=\"global.html#smartMoveToNearestBase\">smartMoveToNearestBase</a>","description":"This function finds the nearest base on the map and moves the agent towards it\nusing the `smartMove` function. If a base is found, it will navigate to that base\nefficiently, taking into account the current map state and obstacles."},{"title":"smartMoveToNearestBaseAndPutDown","link":"<a href=\"global.html#smartMoveToNearestBaseAndPutDown\">smartMoveToNearestBaseAndPutDown</a>","description":"This function finds the nearest base on the map and moves the agent towards it\nusing the `smartMove` function. Once the agent reaches the base, it emits a put down\ncommand for all carried parcels. This is useful for efficiently delivering parcels\nto the nearest base, ensuring that the agent can quickly return to the delivery process."},{"title":"waitForAppReady","link":"<a href=\"global.html#waitForAppReady\">waitForAppReady</a>","description":"This function continuously checks if the player ID is set and the map size is greater than zero.\nIt uses a polling mechanism to wait until these conditions are met before resolving the promise.\nThis is useful to ensure that the application has all necessary data before proceeding with the main logic."}]}